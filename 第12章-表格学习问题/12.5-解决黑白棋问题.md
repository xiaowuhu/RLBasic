
## 12.5 解决黑白棋问题

从第 12.4 节中的描述可知，MCTS算法包括四个主要步骤：选择、扩展、模拟、反向传播。

- 选择（selection），从根节点开始，递归选择 UCB 值最大的节点。如果某个节点的所有子节点都已被访问过，则继续向下选择；否则，停止选择；

- 扩展（expansion），如果当前节点的所有子节点都已被访问过，则选择一个未被访问的子节点进行扩展，创建新的子节点；

- 模拟（simulation），从新扩展的节点开始，使用随机策略进行对局模拟，直到游戏结束，记录最终的胜负结果；

- 反向传播（backpropagation），将模拟的结果（胜负）从叶子节点向上反向传播到根节点，更新路径上每个节点的访问次数和奖励值。

整个过程如图 12.5.1 所示，其中，每个圆角矩形所表示的节点内有两排数字，上面的数字表示节点代号，下面括号中的两个数字只用于表示输赢的棋牌类游戏中，第一个表示智能体赢的次数，第二表示总共进行的游戏次数，而智能体的对手可能是一个人类或者是另外一个智能体。

<img src="./img/mcts-6.png">

图 12.5.1 蒙特卡洛树搜索算法的四个步骤

先看图 12.5.1（a）。首先从根节点下根据某种平衡探索与利用二者关系的算法（一般采用UCB算法）从三个子节点中选择一个，假设选择了子节点1。然后从子节点1扩展棋局，产生子节点4。接下来从子节点4所代表的当前盘面出发，使用随机方法或者其它方法（比如根据人类玩家的历史记录）进行模拟，完成棋局。

再看图 12.5.1（b）。假设在模拟结束后智能体赢得棋局，则把子节点4的第二排数字从（0/0）改成（1/1），表示模拟完成一局，赢了一局。然后进行反向传播，子节点1的第二排数字从（4/6）改成（5/7）。再次向上反向传播，根节点0的第二排数字从（8/15）改成（9/16）。如果智能体输了，则所有节点内第二排的数字中的第一个数字保持不变，第二个数字加1，比如（0/1）、（4/7）、（8/16）。

### 12.5.1 游戏规则

下面我们尝试用MCTS解决黑白棋（Reversi）问题，设定黑棋为人类玩家，白棋为智能体。首先简述黑白棋的规则。

- 初始状态：黑白棋使用一个8×8的棋盘，棋子有黑白两面，一面是黑色，另一面是白色。游戏开始时，棋盘的中心四个格子放置四个棋子，形成一个对角线交叉的模式。如图 12.5.2 所示。

<img src="./img/reversi-0.png" width=300>

图 12.5.2 黑白棋的初始棋局状态

- 游戏规则：两位玩家分别使用黑色和白色棋子，黑方先手，白方后手，双方轮流放置棋子。每次放置棋子时，必须放置在空格上，并且必须至少翻转一个对手的棋子。放置棋子后，如果在放置的棋子和已有的同色棋子之间有连续的对手棋子，则这些对手棋子会被翻转成自己的颜色，翻转可以发生在水平、垂直或对角线方向上。只有能够翻转至少一个对手棋子的放置才是合法的，如果一方没有合法的放置，必须跳过这一轮，由对方继续移动。比如在图 12.5.2 中，黑方的棋子只能放置在1、2、3、4四个位置上。

- 胜负判定：当棋盘上的所有格子都被填满，或者双方都无法进行合法移动时，游戏结束。此时，棋盘上棋子数量多的一方获胜。如果双方的棋子数量相同，则为平局。

### 12.5.2 实现棋局盘面交互

由于棋盘上每个位置有三种状态：

```python
WHITE = -1  # 白棋
BLACK = 1   # 黑棋
EMPTY = 0   # 空位
```

所以整体的状态空间为 $3^{64}$，使用普通的表格学习法是无法承受的。而当使用MCTS解决此问题时，与图 12.5.1 的理论解释不同的地方在于，棋局一旦发展到子节点4后，就再也没有机会回到根节点0去选择子节点2、3了，所以我们每次只需要用当前盘面作为根节点，以当前的有限数量的合法落子位置作为子节点即可，这样复杂度就远远小于理论值 $3^{64}$。

首先实现棋局类，用于绘制和控制棋局盘面的变化：

```python
import tkinter as tk

class GameBoard(object):
    def __init__(self):
        self.board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
        # 初始棋盘布局
        self.board[3][3] = WHITE
        self.board[3][4] = BLACK
        self.board[4][3] = BLACK
        self.board[4][4] = WHITE
        self.current_player = BLACK # 黑方先行
        self.window = tk.Tk()       # 创建窗口
        self.set_title()            # 设置标题
        self.canvas = tk.Canvas(self.window, width=BOARD_SIZE*CELL_SIZE, height=BOARD_SIZE*CELL_SIZE)
        self.canvas.pack()
        self.draw_board()           # 绘制盘面
        self.canvas.bind("<Button-1>", self.on_click)  # 监听鼠标事件
        self.window.mainloop()      # 进入监听循环
```

这里使用了 `tkinter` 包中的方法类提供一个窗口，用于接收鼠标事件和绘制盘面状态。一旦发生鼠标左键事件，则触发下面的函数：

```python
    # 处理鼠标左键点击事件
    def on_click(self, event):
        assert(self.current_player == BLACK)  # 应该是人类玩家
        col = event.x // CELL_SIZE
        row = event.y // CELL_SIZE
        if self.is_valid_move(row, col, BLACK):
            self.make_move(row, col)  # 放置黑色棋子
            self.draw_board()         # 重绘棋盘
            if not self.is_game_over():  # 判断是否棋局结束
                # 切换玩家
                valid_moves = self.get_valid_moves(WHITE)
                if not valid_moves:  # 白方无法落子
                    self.current_player = BLACK  # 轮到黑方
                else:
                    self.current_player = WHITE  # 轮到白方
                    self.window.after(10, self.mcts_search)  # 触发MCTS算法
                self.set_title()
        else:  # 不合法的位置
            messagebox.showinfo("Invalid Move", "Invalid move. Please try again.")
```

### 12.5.3 实现蒙特卡洛树搜索算法

接下来实现树节点类，每一个棋局状态对应到该类中的 `self.board` 属性中。

```python
class MCTSNode:
    def __init__(self, board, move=None, parent=None):
        self.board = board      # 盘面状态
        self.move = move        # 落子位置
        self.parent = parent    # 父节点
        self.children = []      # 子节点列表
        self.visits = 0         # 访问次数
        self.wins = 0           # 赢的次数
    
    def add_child(self, child):  # 添加子节点
        self.children.append(child)
    
    def update(self, result):  # 反向传播时更新计数器
        self.visits += 1
        if result:
            self.wins += 1
    
    def ucb1(self, c=1.414):  # 用UCB1算法选择子节点
        if self.visits == 0:
            return float('inf')
        return self.wins / self.visits + c * math.sqrt(math.log(self.parent.visits) / self.visits)
```

上述代码中用 `self.wins`和`self.visits`表示赢的次数和总共的模拟次数，具体的UCB1算法在 `self.ucb1()` 函数中实现，它的计算公式如下：

$$
\text{UCB1} = \arg\max \Big [\frac{w_c}{n_c} + c\sqrt{\frac{\ln p_c}{n_c}} \Big ]
\tag{12.5.1}
$$

其中，$w_c$ 是子节点赢的次数，$n_c$ 是子节点模拟次数，$p_c$ 是父节点模拟次数（所有子节点模拟次数之和）。有了节点类后，就可以用下面的代码实现树搜索函数了。

```python
    # MCTS 搜索
    def mcts_search(self):
        assert(self.current_player == WHITE)
        root = MCTSNode(self.board)  # 用当前盘面作为根节点
        current_board = deepcopy(self.board)  # 保存原始棋局状态
        # 扩展
        valid_moves = self.get_valid_moves(WHITE)
        if len(valid_moves) == 1: # 只有一种走法，不做搜索
            self.make_move(valid_moves[0][0], valid_moves[0][1])
        else:
            # 有多种走法，建立子节点
            for valid_move in valid_moves:
                self.board = deepcopy(current_board)  # 从原始棋局拷贝状态
                self.make_move(valid_move[0], valid_move[1])  # 白棋走一步
                child = MCTSNode(self.board, valid_move, root)
                root.add_child(child)  # 建立子节点并加入根节点列表
```

上面的代码片段根据当前盘面建立了根节点和子节点，比如在进行到图 12.5.3 所示的对局中的某个状态时，此时轮到智能体落子，所以在标题条中显示 `Reversi: White -> Thinking...` 文字表示白方正在“思考”，而它的思考范围是1~6所示的六个子节点。

<img src="./img/reversi-1.png" width=300>

图 12.5.3 对剧中的某个状态

下面的代码片段开始进行模拟。首先使用UCB1算法选择子节点，然后使用随机算法进行模拟，直到棋局结束，最后从 1000 轮模拟的结果中选择获胜次数最多的子节点所对应的落子位置，作为本次MCTS的结果进行实际的棋局。

```python
            # 开始模拟
            for _ in range(1000):  # 用模拟的轮数可以控制“思考”时间
                # 选择
                node: MCTSNode = max(root.children, key=lambda n: n.ucb1())
                # 模拟一直到棋局结束
                ...
                # 如果走到这一行，说明双方无棋可走，本次模拟棋局结束，开始反向传播
                result = self.evaluate_board()  # 判断胜负
                while node:
                    node.update(result)  # 更新节点的计数器
                    node = node.parent   # root.parent == None
            # 1000轮模拟结束，选择最佳落子位置
            best_child = max(root.children, key=lambda n: n.wins)
            self.current_player = WHITE
            self.board = deepcopy(current_board)  # 从原始棋局拷贝状态
            self.make_move(best_child.move[0], best_child.move[1])
        self.draw_board()
```

在模拟棋局时使用了随机方法，由于总共模拟的了1000次，所以假设随机方法可以覆盖所有可能性。如果假设不成立的话，可以增加模拟次数进行近似求解。在黑白棋中与围棋一样有“金角银边草肚皮”的说法，所以，在经过大量的模拟后，智能体的最佳选择是图 12.5.3 中的1号位置，如图 12.5.4 所示，其中的灰色小圆是提示黑方（人类玩家）合法的落子位置。

<img src="./img/reversi-2.png" width=300>

图 12.5.4 选择边角位置以达到最大获胜可能

在这一轮中，虽然智能体只翻动了黑方一个子，但是却占据了左上角位置，不可能再被黑方翻转。这一特点在代码中并没有体现，但是智能体可以从大量的模拟中捕捉到这个胜利的机会。

值得一提的是，【代码：MCTS_1_GameBoard.py】中的大部分代码是由 AI 生成的，它可以运行，但是得不到最好的结果。比如下面这行代码：

```python
best_child = max(root.children, key=lambda n: n.wins)
```

这里没有用UCB1算法，而是使用了贪婪算法。AI的原始输出是：

```python
best_child = max(root.children, key=lambda n: n.visits)
```

这样就不能保证智能体的高胜率，因为被访问次数多的子节点不一定是最佳选择。
